# Java Interview

## Intro

- 코딩 테스트: BFS, DFS, Graph, 최단거리, two pointer, 문자열 알고리즘, BST, MST, 분할정복

## CS

> 컴퓨터가 부동 소수점을 제대로 표현하지 못하는 이유?

> Call by Reference Call By Value

## Java

> 객체 지향 4때 특성

> 객체 지향 설계 원칙 SOLID

> Java synchronized 키워드란?

> singleton 이란

> 인터페이스와 상속의 차이

> JVM 메모리 구조 & Garbage Collection

> Java Stack 구조 와 중요한 이유

> Generic 없이 타입 체킹이 가능한 이유

> Java 8 stream API의 특징

> OOM이 발생하는 원인

> Java 와 코틀린

- 자바와 비교한 코틀린의 장점

> Thread 생성 라이프 사이클

> volatile

> HashMap 과 ConcurrentHashMap 차이 (synchronized)


## Object-oriented programming

> 추상화란?

> 상속 대신 합성을 해야 하는 이유?


## Spring Framework

> IOC

> Spring 3대 요소

- DI

- AOP

- PSA

> 스프링 MVC의 라이프 사이클

> Bean의 라이프 사이클

> **@ControllerAdvice**의 내부 동작 방식

> @Transactional 동작 방식

> @RequestBodyAdvice 개념

> Spring Batch 트랜잭션 적용 방식

> Transaction Propagation

> REST API

## OS

> Multi-Thread 와 Multi-Process

> Context Switching

## DB

> CAP

> DB Index

> DB Transaction Isolation

> 데이터 모델링 정규화

> 쿼리 비용 처리에 최적화 방법

> RDB와 NoSQL 차이

> Optimistic Lock 과 Pessimistic Lock

> 데드락의 원인 및 해결 방안

> MySQL 페이징 이슈

> **DB Sharding**시 자료의 위치를 찾는 방법

## JPA

> JPA를 사용하는 이유?

> spring-data-jpa를 구성하는 요소

> 낙관적 락과 비관적 락

> 낙관적 락의 @Version

> N + 1 이슈
