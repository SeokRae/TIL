# Java Interview

## Intro

- 코딩 테스트: BFS, DFS, Graph, 최단거리, two pointer, 문자열 알고리즘, BST, MST, 분할정복

## CS

> 컴퓨터가 부동 소수점을 제대로 표현하지 못하는 이유?

> Call by Reference Call By Value

## Java

> 객체 지향 4때 특성

> 객체 지향 설계 원칙 SOLID

> Java synchronized 키워드란?

> singleton 이란

> 인터페이스와 상속의 차이

> JVM 메모리 구조 & Garbage Collection

- G1GC 사용 이유와 근거

> Java Stack 구조 와 중요한 이유

> Generic 없이 타입 체킹이 가능한 이유

> Java 8 stream API의 특징

> OOM이 발생하는 원인

> Java 와 코틀린

- 자바와 비교한 코틀린의 장점

> Thread 생성 라이프 사이클

> volatile

> HashMap 과 ConcurrentHashMap 차이 (synchronized)

> 람다 설명

> 함수형프로그래밍

> 람다와 익명함수의 차이점

> 디비커넥션풀 갯수

> 체크드익셉션 언체크드익셉션

> 익셉션과 에러의 차이

> 동일성과 동등성, 힙영역에서 메모리충돌날 수 있는가?

## Object-oriented programming

> 추상화란?

> 상속 대신 합성을 해야 하는 이유?

> 컴포지트랑 상속

> 객체지향중 가장 중요시 생각하는 점

## Spring Framework

> DI

> IOC

> Spring 3대 요소

- DI

- AOP
  - 동작원리

- PSA

> 스프링 MVC의 라이프 사이클

> Bean의 라이프 사이클

> @ComponentScan 동작 방식

> **@ControllerAdvice**의 내부 동작 방식

> @Transactional 동작 방식

> @RequestBodyAdvice 개념

> Spring Batch 트랜잭션 적용 방식

> Transaction Propagation

> REST API

## OS

> Multi-Thread 와 Multi-Process

> Context Switching

## DB

> CAP

> DB Index

> DB Transaction Isolation

> 데이터 모델링 정규화

> 쿼리 비용 처리에 최적화 방법

> RDB와 NoSQL 차이

> Optimistic Lock 과 Pessimistic Lock

> 데드락의 원인 및 해결 방안

> MySQL 페이징 이슈

> **DB Sharding**시 자료의 위치를 찾는 방법

> hint 란?

> 쿼리가 인덱스를 타지 않을 때, 어떻게 해결할까?

> 트랜잭션 업데이트와 셀렉트 있을 때 셀렉트 실패 시 업데이트는 진행되게

## JPA

> JPA를 사용하는 이유?

> spring-data-jpa를 구성하는 요소

> 낙관적 락과 비관적 락

> 낙관적 락의 @Version

> N + 1 이슈

## Git

> 포크와 클론의 차이점과 장단점

> 리베이스 설명
