# Prototype Pattern

### 참고

* [Prototype - refactoring.guru](https://refactoring.guru/design-patterns/prototype)
* [Prototype Pattern in Java - baeldung](https://www.baeldung.com/java-pattern-prototype)
* [effective java - item13](https://github.com/SeokRae/TIL/tree/fc6c10a60a95a564748bcc7f550358bfcf5f5eff/java/contents/effactive/item_13.md)

## 프로토 타입 패턴?

* 기존 개체를 복사하여 새 개체를 만드는 작업
* 복사본이 만들어지는 개체를 **프로토 타입**이라 한다.

### 프로토 타입 객체을 사용하는 이유?

* 성능을 염두하는 경우 **중복 개체** 를 만들어 신규 개체를 생성하는데 드는 비용을 최소화하기 위함이다.

## 프로토 타입 디자인의 구성 요소

* **프로토 타입**\(인터페이스로 제공\)
	* 실체 객체의 프로토 타입
* **프로토 타입 레지스트리**\(구체화 클래스\)
	* 특정 기준 매개 변수를 사용하여 모든 프로토타입에 액세스 할 수 있도록 레지스트리 서비스로 사용
* **클라이언트**
	* 클라이언트는 프로토 타입 인스턴스에 액세스하기 위해 레지스트리 서비스를 사용할 책임이 있다.

## 구현 방법

* 전체 패턴의 구조를 잡아줄 **프로토타입 인터페이스\(또는 추상클래스\)** 를 선언하여 **clone\(\)** 연산을 구현한다.
* 복제 작업을 진행할 클래스를 구현한다.
* 프토로타입 복제를 통해 새로운 객체를 만든다.

## 프로토 타입 디자인 패턴의 장점

* **런타임** 시기에 객체를 추가하거나 제거할 수 있다.
	* 프로토 타입을 사용하면 **클라이언트**에 **프로토 타입 인스턴스를 등록**하기만하면 **새로운 구체적인 제품 클래스를 시스템에 통합** 할 수 있다.
	* **클라이언트**가 **런타임**에 프로토 타입을 **설치**하고 **제거**할 수 있기 때문에 다른 생성 패턴보다 약간 더 유연합니다.
* 다양한 **값**에 따른 새 객체를 지정
	* 동적인 시스템을 사용하면 새 클래스를 정의하는 것이 아니라 개체의 변수에 대한 값을 지정하여 개채 구성을 통해 새 동작을 정의할 수 있다.
* 다양한 **구조**에 따른 새 객체를 지정
	* 많은 응용 프로그램이 부품 및 하위 부품에서 개체를 작성한다.
	* 편의를 위해 이러한 응용 프로그램을 사용하면 복잡한 사용자 정의 구조를 인스턴스화하여 반복하여 사용할 수 있다.
* **서브 클래스** 구현 감소
	* Factory Method는 종종 Product 클래스 계층 구조와 유사한 Creator 클래스 계층 구조를 생성한다.
	* 프로토 타입 패턴을 사용하면 팩토리 메서드에 새 객체를 만드는 대신 프로토 타입을 복제 할 수 있다.
	* 따라서 Creator 클래스 계층 구조가 필요하지 않는다.

## 프로토 타입 디자인 패턴의 단점

* 프로토타입은 서브클래싱을 필요로 하지 않는다. 하지만 "초기화" 동작을 필요로 한다.

## 얕은 복사 vs 깊은 복사

* 프로토 타입 패턴을 사용하기 위해서는 프로토 타입 클래스 또는 인터페이스가 clone\(\) 메서드를 구현해야 한다.
	* 얕은 복사는 복제된 객체는 프로토 타입과 동일한 개체를 가리킨다.
		* 그러므로 엔진 객체는 결국 둘 사이에 공유된다.
	* 깊은 복사를 통해 복제된 개체는 자체 엔진 자체와 그 안에 중첩 된 개체의 복사본을 가져온다.
		* 그러므로 프로토 타입과 복제본간에 필드가 중첩된다거나 공유되지 않는다.

### Mutable Object, Immutable Object

* 프로토 타입 내에 Primitive Type의 필드만 존재하는 경우 얕은 복사\(Shallow\)
* 프로토 타입 내에 또 다른 객체가 존재하는 경우 깊은 복사\(Deep Copy\)
* 프로토 타입을 복제하여 만들어진 인스턴스의 내부에 있는 참조형 자료형들이 존재하는 경우, 생성된 인스턴스들은 참조형 자료형 필드를 서로 공유하게 된다.

## 동적 로딩

* 프로토 타입 패턴은 클래스의 Dynamic Loading 에도 도움이 된다.
* 동적 로드를 허용하는 언어 프레임워크는 로드된 클래스의 인스턴스를 만들고 관리 엔티티에 등록한다.
* 응용 프로그램은 런타임에 관리자로부터 로드 된 클래스의 개체를 요청할 수 있다.
* 응용 프로그램은 클래스의 생성자에 정적으로 액세스 할 수 없다.

## Java API

* java.lang.Cloneable
* clone\(\) 메서드는 Object 클래스에서 퍼블릭 인터페이스로 제공된다.

## 예시 코드

* clone\(\)을 사용해서 구현하는 방법

2. Abstract Class -&gt; Cloneable 구현
3. Concrete Class -&gt; @Override clone\(\)

* Class 제공하는 방식

1. cache
2. prototype
