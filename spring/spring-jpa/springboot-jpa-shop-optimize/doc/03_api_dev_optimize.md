## API 개발 고급 - 실무 필수 최적화

- 알아야 하는 설정 관리

> 미리보기

- 고객 서비스의 실시간 API에서는 OSIV는 끈다.
- Admin 처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켠다.

### OSIV와 성능 최적화

- Open Session In View: 하이버네이트
- Open EntityManager In View: JPA
  (관례상 OSIV라 칭한다.)

> OSIV ON 전략

- `장점`
	- 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지
	- 위 기능으로 인하여 View Template 이나 API Controller에서 지연 로딩이 가능했던 것이다.
	- 지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다.
- `단점`
	- 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 어플리케이션에서는 커넥션이 부족할 수 있다.
	- 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고 유지하다가 장애가 발생 할 수 있다.
- `설정`
  ```yml
  # 기본 값 True
  spring.jpa.open-in-view: true
  ```

> OSIV OFF 전략

- `장점`
	- 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. 이는 커넥션 리소스를 낭비하지 않는 장점을 가질 수 있다.
- `단점`
	- 모든 지연로딩을 트랜잭션 안에서 처리해야한다.
	- view template에서 지연로딩이 동작하지 않아 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.

- `문제의 해결책` [참고](https://en.wikipedia.org/wiki/Command–query_separation)
	- OrderQueryService라는 클래스를 따로 작성(지연로딩관련 로직관리 클래스)하여 해결
	- 비즈니스 로직은 특정 엔티티 몇개를 등록하거나 수정하는 것이므로 성능에 문제가 되지않는다.
	- 복잡한 화면을 출력하기 위해서 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요
	- 크고 복잡한 애플리케이션을 개발한다면, 두 관심사를 명확하게 분리하는 선택을 하도록 한다.
		- OrderService: 핵심 비즈니스 로직
		- OrderQuerySerivce: 화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션 사용)
- `설정`
  ```yml
  # 기본 값 True
  spring.jpa.open-in-view: false
  ```
